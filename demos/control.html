<!doctype html>
<!--
Multi-touch game controller demo. Original work by @seb_ly and Boris Smus.

For more information, see
http://sebleedelisle.com/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad

Modified to use Gesture.js by David Thevenin. For more information, see
https://github.com/dthevenin/Gesture.
-->
<html lang=en>
  <head>
    <meta charset=utf-8>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0" /> 
    <title></title>
    <style type="text/css"> 

      * {
        -webkit-touch-callout: none; /* prevent callout to copy image, etc when tap to hold */
        -webkit-text-size-adjust: none; /* prevent webkit from resizing text to fit */
        /* make transparent link selection, adjust last value opacity 0 to 1.0 */
        -webkit-tap-highlight-color: rgba(0,0,0,0); 
        -webkit-user-select: none; /* prevent copy paste, to allow, change 'none' to 'text' */
        -webkit-tap-highlight-color: rgba(0,0,0,0); 
        -ms-touch-action: none;
        touch-action: none;
      }

      body {
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }
      canvas {
        display:block; 
        position:absolute; 
      }
      .container {
        width:auto;
        text-align:center;
        background-color:#ff0000;
      }
    </style>
  </head>
  <body>
    <script src="js/Vector2.js"></script>
    <script src="../build/firminCSSMatrix_min.js"></script>
    <script src="../build/vs_util_min.js"></script>
    <script src="../build/vs_transform_min.js"></script>
    <script src="../build/vs_gesture_min.js"></script>

    <script src="js/ShipMovingTouch.js"></script>
    <script src="js/BulletSebs.js"></script>
    <script>
      var canvas,
      ctx, // ctx is the canvas' context 2D
      container, 
      halfWidth, 
      halfHeight,
      leftPointerID = -1, 
      leftPointerPos = new Vector2(0,0),
      leftPointerStartPos = new Vector2(0,0),
      leftVector = new Vector2(0,0); 

      setupCanvas ();

      var	pointers = [], // array of touch vectors
      ship = new ShipMoving (halfWidth, halfHeight)
      bullets = [],
      spareBullets = [];

      document.body.appendChild (ship.canvas);

      //setInterval(draw, 1000/35); 
      vs.requestAnimationFrame (draw);

      vs.addPointerListener (canvas, vs.POINTER_START, onPointerDown, false);
      window.onorientationchange = resetCanvas;  
      window.onresize = resetCanvas;  

      function resetCanvas (e) {  
        // resize the canvas - but remember - this clears the canvas too. 
        canvas.width = window.innerWidth; 
        canvas.height = window.innerHeight;

        halfWidth = canvas.width/2; 
        halfHeight = canvas.height/2;

        //make sure we scroll to the top left. 
        window.scrollTo (0,0); 
      }

      function draw () {

        ctx.clearRect (0,0,canvas.width, canvas.height); 

        ship.targetVel.copyFrom (leftVector);
        ship.targetVel.multiplyEq (0.15);

        ship.update(); 

        with(ship.pos) {
          if (x < 0) x = canvas.width; 
          else if (x > canvas.width) x = 0;
          if (y < 0) y = canvas.height; 
          else if (y > canvas.height) y = 0; 
        }

        ship.draw(); 

        for (var i = 0; i < bullets.length; i++) {
          var bullet = bullets [i]; 
          if (!bullet.enabled) continue; 
          bullet.update (); 
          bullet.draw (ctx); 
          if (!bullet.enabled)
          {
            spareBullets.push (bullet); 
          }
        }

        for (var i = 0; i < pointers.length; i++) {

          var pointer = pointers [i]; 

          if (pointer.identifier === leftPointerID) {
            ctx.beginPath (); 
            ctx.strokeStyle = "cyan"; 
            ctx.lineWidth = 6; 
            ctx.arc (leftPointerStartPos.x, leftPointerStartPos.y, 40,0,Math.PI*2,true); 
            ctx.stroke ();
            ctx.beginPath (); 
            ctx.strokeStyle = "cyan"; 
            ctx.lineWidth = 2; 
            ctx.arc (leftPointerStartPos.x, leftPointerStartPos.y, 60,0,Math.PI*2,true); 
            ctx.stroke ();
            ctx.beginPath (); 
            ctx.strokeStyle = "cyan"; 
            ctx.arc (leftPointerPos.x, leftPointerPos.y, 40, 0,Math.PI*2, true); 
            ctx.stroke (); 

          } else {

            ctx.beginPath (); 
            ctx.fillStyle = "white";
            ctx.fillText (pointer.type + " id : "+pointer.identifier+" x:"+pointer.pageX+" y:"+pointer.pageY, pointer.pageX+30, pointer.pageY-30); 

            ctx.beginPath (); 
            ctx.strokeStyle = "red";
            ctx.lineWidth = "6";
            ctx.arc (pointer.pageX, pointer.pageY, 40, 0, Math.PI*2, true); 
            ctx.stroke ();
          }
        }

        vs.requestAnimationFrame (draw);
      }

      function makeBullet () {

        var bullet;

        if (spareBullets.length > 0) {

          bullet = spareBullets.pop (); 
          bullet.reset (ship.pos.x, ship.pos.y, ship.angle); 

          } else {

          bullet = new Bullet (ship.pos.x, ship.pos.y, ship.angle); 
          bullets.push (bullet);
        }
        bullet.vel.plusEq (ship.vel); 
      }

      var _move_listening = false;

      function onPointerDown (e) {
        e.preventDefault ();
        pointers = e.pointerList;

        if (!_move_listening)
        {
          vs.addPointerListener (canvas, vs.POINTER_MOVE, onPointerMove, false);
          vs.addPointerListener (canvas, vs.POINTER_END, onPointerUp, false);
          _move_listening = true;
        }
  
        for (var i = 0; i < e.nbPointers; i++) {
          var pointer = pointers [i]; 
          if ((leftPointerID < 0) && (pointer.pageX < halfWidth))
          {
            leftPointerID = pointer.identifier; 
            leftPointerStartPos.reset (pointer.pageX, pointer.pageY); 	
            leftPointerPos.copyFrom (leftPointerStartPos); 
            leftVector.reset (0,0); 
            continue; 		
          } else {
            makeBullet(); 
          }	
        }
      }

      function onPointerMove (e) {
        // Prevent the browser from doing its default thing (scroll, zoom)
        pointers = e.pointerList;

        for (var i = 0; i < e.nbPointers; i++){
          var pointer = pointers[i]; 
          if (leftPointerID === pointer.identifier)
          {
            leftPointerPos.reset (pointer.pageX, pointer.pageY); 
            leftVector.copyFrom (leftPointerPos); 
            leftVector.minusEq (leftPointerStartPos); 	
            break; 		
          }		
        }
      } 

      function onPointerUp (e) { 

        if (e.nbPointers === 0)
        {
          vs.removePointerListener (canvas, vs.POINTER_MOVE, onPointerMove, false);
          vs.removePointerListener (canvas, vs.POINTER_END, onPointerUp, false);
          _move_listening = false;
        }

        pointers = e.pointerList; 
        if (e.nbPointers === 0) {
          leftPointerID = -1; 
          if (e.type === vs.PointerTypes.TOUCH) {
            leftVector.reset (0,0); 
          }
        }
      }

      function setupCanvas() {

        canvas = document.createElement ('canvas');
        ctx = canvas.getContext ('2d');
        container = document.createElement ('div');
        container.className = "container";

        document.body.appendChild (container);
        container.appendChild (canvas);	

        resetCanvas ();

        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;	
      }
      </script>
    </body>
  </html>